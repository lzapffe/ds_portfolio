<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Vectorized Operations</title>

<script src="site_libs/header-attrs-2.29/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Portfolio for the Data Science with R Class</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
<li>
  <a href="p01.html">Project 1</a>
</li>
<li>
  <a href="p02.html">Project 2</a>
</li>
<li>
  <a href="p03.html">Project 3</a>
</li>
<li>
  <a href="p04.html">Project 4</a>
</li>
<li>
  <a href="p05.html">Project 5</a>
</li>
<li>
  <a href="p06.html">Project 6</a>
</li>
<li>
  <a href="p07.html">Project 7</a>
</li>
<li>
  <a href="p08.html">Project 8</a>
</li>
<li>
  <a href="p09.html">Project 9</a>
</li>
<li>
  <a href="p10.html">Project 10</a>
</li>
<li>
  <a href="p11.html">Project 11</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Vectorized Operations</h1>

</div>


<p>One thing that I have always struggled with, going from programming
in Python to R, is vectorized operations. I feel like loops make a lot
of sense, and when planning out the logic of some code, or writing it, I
can easily figure out how to do it with loops, but I struggle figure out
how to think about it with vectorized operations. I think part of that
is that it just takes a mentality shift and the other part is that I
don’t know how the functions for vectorized operations work well enough.
Therefore, with this project, I will take a deep-dive into vectorized
operations and get some practice with it, so that I hopefully feel
confident using vectorized operations later on when writing code.</p>
<p>Goals for the project:</p>
<ul>
<li>Learning about the logic of vectorized operations</li>
<li>Learning about the different functions for vectorized operations in
R, including apply(), lapply(), and mapply()</li>
<li>Comparing and contrasting writing vectorized vs looped code</li>
<li>Getting more experience with vectorized operations so that I can
confidently apply it to future coding projects</li>
</ul>
<div id="the-basics-of-vectorized-operations" class="section level1">
<h1>The Basics of Vectorized Operations</h1>
<div id="examples-of-simple-vectorized-operations"
class="section level2">
<h2>Examples of simple vectorized operations</h2>
<p>This <a
href="https://bookdown.org/rdpeng/rprogdatascience/vectorized-operations.html">book
chapter</a> had a good example of really basic vectorized operations.
Contrasting the following two ways of adding two vectors:</p>
<pre class="r"><code>x &lt;- 1:4
y &lt;- 6:9 
z &lt;- x + y
z</code></pre>
<pre><code>## [1]  7  9 11 13</code></pre>
<pre class="r"><code>x &lt;- 1:4
y &lt;- 6:9
for(i in seq_along(x)) {
      z[i] &lt;- x[i] + y[i]
}
z</code></pre>
<pre><code>## [1]  7  9 11 13</code></pre>
<p>When seeing it written out like that, I realize that I already use
some basics of vectorized operations.</p>
<p>Similarly, this is also vectorized operations:</p>
<pre class="r"><code>x &lt;- 1:4

x &gt; 2</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE  TRUE</code></pre>
<p>This is with matrices:</p>
<pre class="r"><code>x &lt;- matrix(1:4, 2, 2)
y &lt;- matrix(rep(10, 4), 2, 2)
print(x)</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4</code></pre>
<pre class="r"><code>print(y)</code></pre>
<pre><code>##      [,1] [,2]
## [1,]   10   10
## [2,]   10   10</code></pre>
<pre class="r"><code>x * y </code></pre>
<pre><code>##      [,1] [,2]
## [1,]   10   30
## [2,]   20   40</code></pre>
</div>
<div id="the-different-functions-for-vectorized-operations-in-r"
class="section level2">
<h2>The different functions for vectorized operations in r</h2>
<p>This information is taken from on chapter 16 - <a
href="https://bookdown.org/rdpeng/rprogdatascience/loop-functions.html">Loop
Functions</a> in the open source textbook “R programming for data
science”</p>
<div id="lapply" class="section level3">
<h3>lapply()</h3>
<p>lapply() returns a list, hence the “l”.</p>
<p>It takes three arguments, a list to do an operation on, the function,
and any other parameters</p>
<p>If the input is not a list, it will be converted to a list
automatically using as.list()</p>
<p>When you pass a function through lapply() (second parameter), it will
input the list you have as the first parameter of that function. For
example, in mean(), the first argument is the object to calculate the
mean from and the rest of the parameters include e.g. whether parts of
the object should be trimmed (with trim).</p>
<p>If the function you pass through lapply() has more parameters that
you want to specify, such as trim = 0 in mean(), you can add those as
extra parameters to lapply() and they will be passed down into the
function you specify. For example, you could here have written lapply(x,
mean, trim = 0).</p>
<p>You can enter functions that you define yourself into lapply(). You
can even define it in the lapply() function itself. for example as
“lapply(x, function(elt) { elt[,1] })”. This creates an
<strong>anonymous function</strong> that only exists for the lapply()
command and then disappears.</p>
</div>
<div id="sapply" class="section level3">
<h3>sapply()</h3>
<p>sapply() is very similar to lapply(), but it simplifies the results.
For example, if you run lapply() on a vector with three items, it will
return a nested list where each list has one item each. However, if you
run sapply() it will make it one vector with several items. Similarly,
if all lists that you input has the same number of items, sapply() will
make it into a matrix, instead of nested lists. However, if none of
these two situations apply, it will just produce the same nested lists
as lapply() does.</p>
<p>See here for an example taken from the book chapter:</p>
<pre class="r"><code>x &lt;- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)</code></pre>
<pre><code>## $a
## [1] 2.5
## 
## $b
## [1] -0.3107703
## 
## $c
## [1] 0.6734722
## 
## $d
## [1] 4.983619</code></pre>
<pre class="r"><code>x &lt;- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
sapply(x, mean)</code></pre>
<pre><code>##          a          b          c          d 
##  2.5000000 -0.4226360  0.7609175  4.8409374</code></pre>
</div>
<div id="vapply" class="section level3">
<h3>vapply()</h3>
<p>Similar to sapply and lapply(), but you can define what type of input
you are expecting. For example, using FUN.VALUE = numeric(1) says that
you are expecting the input to be numeric, with a single digit.
FUN.VALUE = data.frame(1) indicates that you are expecting a single data
frame. If the input is not in the excepted format, you will get an
error. This can be helpful for example if you have string numbers, but
want them to be numeric. Using vapply() instead of sapply() or lapply()
then adds in a check for variable type and can create an error, instead
of having a silent error happen later in the code. There is an argument
for simplifying the output that produces similar output as lapply() or
sapply().</p>
</div>
<div id="tapply" class="section level3">
<h3>tapply()</h3>
<p>It sort of groups part of your vector together. So instead of maybe
having a nested list like x &lt;- c((1, 2, 3,),(4, 5, 6),(7, 8, 9)), you
can have the list x &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9) and the list y
&lt;- c(1, 1, 1, 2, 2, 2, 3, 3, 3). You can then define to group the
calculations in x by the membership in y with tapply().</p>
<p>For example, tapply(x, y, mean)</p>
<p>There is also a parameter called simplify (TRUE or FALSE). If it is
true it gives output similar to that of sapply(), while if it is false,
it will give output similar to that of lapply(). If it is true, the
output will always be an array. An array is similar to a matrix, as a
matrix is a 2 dimensional array.</p>
</div>
<div id="apply" class="section level3">
<h3>apply()</h3>
<p>Used on an array, like a matrix. You can specify which direction you
want it to act on, either rows or columns.</p>
<p>The second parameter, called MARGINS, determine whether you apply the
function to the column or the row. If the value is 1, you collapse the
columns and retain the rows. If the value is 2, you collapse the rows
and retain the columns. See the following examples, taken from the
bookchapter, for reference:</p>
<pre class="r"><code>x &lt;- matrix(rnorm(200), 20, 10)
apply(x, 2, mean)  ## Take the mean of each column</code></pre>
<pre><code>##  [1] -0.05476248  0.08801030  0.20328432  0.16957234 -0.21461377 -0.42816045
##  [7]  0.13711626  0.08920606 -0.44559500  0.07361317</code></pre>
<pre class="r"><code>x &lt;- matrix(rnorm(200), 20, 10)
apply(x, 1, sum)   ## Take the mean of each row</code></pre>
<pre><code>##  [1] -1.2026622 -3.1323678  2.0997132  1.4442149 -2.7783634  1.6685869
##  [7] -0.6173170 -2.7266519  1.2372130 -2.4744345  0.1728629  0.3819699
## [13] -3.3699461 -4.9873725  1.6828111  3.6103156  0.4366493 -0.2161430
## [19] -0.6927168  4.8013746</code></pre>
<p>The following are some examples of functions that could be written as
apply()</p>
<p>rowSums = apply(x, 1, sum) rowMeans = apply(x, 1, mean) colSums =
apply(x, 2, sum) colMeans = apply(x, 2, mean</p>
</div>
<div id="mapply" class="section level3">
<h3>mapply()</h3>
<p>mapply() can iterate over multiple r objects at the time, like
running lapply() in paralell.</p>
<p>For mapply(), the first parameter is the function, not the object to
run it for.</p>
<p>Here is an example of how mapply() saves space. For example, instead
of writing</p>
<pre class="r"><code>list(rep(1, 4), rep(2, 3), rep(3, 2), rep(4, 1))</code></pre>
<pre><code>## [[1]]
## [1] 1 1 1 1
## 
## [[2]]
## [1] 2 2 2
## 
## [[3]]
## [1] 3 3
## 
## [[4]]
## [1] 4</code></pre>
<p>You can use mapply() and write</p>
<pre class="r"><code>mapply(rep, 1:4, 4:1)</code></pre>
<pre><code>## [[1]]
## [1] 1 1 1 1
## 
## [[2]]
## [1] 2 2 2
## 
## [[3]]
## [1] 3 3
## 
## [[4]]
## [1] 4</code></pre>
<p>Here, 1:4 is passed to rep as the first parameter and 4:1 as the
second.</p>
<p>You can also use mapply() to run vectorized operations with functions
that do not support vectorized operations. For example, here is how the
book chapter demonstrated it:</p>
<pre class="r"><code>sumsq &lt;- function(mu, sigma, x) {
         sum(((x - mu) / sigma)^2)
}

# Generate data in a list
x &lt;- rnorm(100)</code></pre>
<p>Here we are defining a function to calculate sums of squares and we
want to do it for values of mu and sigma increasing from 1 to 10. If we
try doing this in the function itself, which is not adapted for
vectorized operations, we only get one number.</p>
<pre class="r"><code>sumsq(1:10, 1:10, x)  ## This is not what we want</code></pre>
<pre><code>## [1] 121.3082</code></pre>
<p>While we can apply mapply() to run the 10 values in paralell.</p>
<pre class="r"><code>mapply(sumsq, 1:10, 1:10, MoreArgs = list(x = x))</code></pre>
<pre><code>##  [1] 181.61298 116.80949 105.87366 102.40550 100.96452 100.27050  99.90536
##  [8]  99.70294  99.58781  99.52238</code></pre>
<p>You can also apparently do this with the Vectorize() function</p>
<pre class="r"><code>vsumsq &lt;- Vectorize(sumsq, c(&quot;mu&quot;, &quot;sigma&quot;))
vsumsq(1:10, 1:10, x)</code></pre>
<pre><code>##  [1] 181.61298 116.80949 105.87366 102.40550 100.96452 100.27050  99.90536
##  [8]  99.70294  99.58781  99.52238</code></pre>
<p>I don’t think I fully understand how this works yet, but I might get
it a little more later. Or it might not be the most important thing to
know.</p>
<p>mapply differs from e.g. lapply if you have multiple lists and
elements as lapply iterates through each list in total, while mapply
iterates through each element in a list, not necessarily iterating over
each list per iteration like lapply does. See exercise 13 for an
example.</p>
</div>
<div id="split" class="section level3">
<h3>split()</h3>
<p>The book chapter also mentions split(), as this seems to often be
used with vectorized operations. You can use it to divide out a part of
the items and run a function only on these. It takes the parameters x
(vector or data frame), function, and drop = TRUE/FALSE. Seems like it
works with factors.</p>
<pre class="r"><code>x &lt;- c(rnorm(10), runif(10), rnorm(10, 1))
f &lt;- gl(3, 10)
print(f)</code></pre>
<pre><code>##  [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3
## Levels: 1 2 3</code></pre>
<pre class="r"><code>split(x, f)</code></pre>
<pre><code>## $`1`
##  [1] -0.9706373  1.0461454 -0.4081018  0.5292572  0.8528591 -0.1334782
##  [7]  0.8197633  0.6431363 -0.6639123 -2.1674846
## 
## $`2`
##  [1] 0.61899369 0.51424101 0.78116060 0.02568869 0.69256446 0.61800854
##  [7] 0.31398035 0.23270333 0.02292010 0.58076062
## 
## $`3`
##  [1]  0.3107843  0.8207667  2.7980980  0.4211566  2.1489083  1.7839261
##  [7]  1.4778491  0.4113216 -0.2345241  0.7249822</code></pre>
<p>This seems very similar to tapply(), but with factors instead of just
a list.</p>
<p>This is an example in combination with lapply()</p>
<pre class="r"><code>lapply(split(x, f), mean)</code></pre>
<pre><code>## $`1`
## [1] -0.0452453
## 
## $`2`
## [1] 0.4401021
## 
## $`3`
## [1] 1.066327</code></pre>
<p>With this, you can for example look at a data frame and split up the
calculations or stats based on a variable (as a factor), such as month
or city. You can even split it up in combinations of two or more
variables, e.g. with (split(x, list(f1, f2))).</p>
<p>Remember from earlier, that tapply() is like split() and lapply(),
but for vectors only. That means that you cannot use it on data
frames.</p>
</div>
</div>
<div id="check-in" class="section level2">
<h2>Check-in</h2>
<p>Ok, I think I am starting to get a basic overview of the different
functions, what they do, and how they work. Now, I think I might need
some practice actually using them. I have asked ChatGPT to come up with
exercises for me, so I will use that to get more comfortable using these
vectorized operations.</p>
</div>
</div>
<div id="practice" class="section level1">
<h1>Practice!</h1>
<p>So far, I have learned about apply(), lapply(), sapply(), vapply(),
tapply(), mapply(), and split() with lapply(). I know need some practice
using these functions to get comfortable with the logic behind them,
when to use each, and how they work.</p>
<p>First, I fed ChatGPT with all the notes I have up until this point
and asked it to make some exercises, with varying difficulty, that could
be used to practice what is in this document so far and further deepen
my understanding. Here are some exercises and my solutions to them from
ChatGPT. Some of them might be slightly modified:</p>
<div id="simple-vectorized-operations" class="section level3">
<h3>1. Simple Vectorized Operations</h3>
<p>1.1. Create two vectors, a &lt;- 1:5 and b &lt;- 6:10. Then use
vectorized operations for the next steps.</p>
<pre class="r"><code>a &lt;- c(1:5)
b &lt;- c(6:10)
print(a)</code></pre>
<pre><code>## [1] 1 2 3 4 5</code></pre>
<pre class="r"><code>print(b)</code></pre>
<pre><code>## [1]  6  7  8  9 10</code></pre>
<p>Little reminder to myself: lists differ from vectors as a vector can
only have one type of items, e.g. numbers, characters, or logical
values, while lists can have a mix. You define a vector with c() and a
list with list(). I am pretty sure a c() with multiple data types will
just automatically be converted to a list, since R tends to to that type
of stuff.</p>
<p>1.2. Add, subtract, multiply, and divide the vectors.</p>
<pre class="r"><code>c &lt;- a + b
print(c)</code></pre>
<pre><code>## [1]  7  9 11 13 15</code></pre>
<pre class="r"><code>d &lt;- a - b
print(d)</code></pre>
<pre><code>## [1] -5 -5 -5 -5 -5</code></pre>
<pre class="r"><code>e &lt;- a * b
print(e)</code></pre>
<pre><code>## [1]  6 14 24 36 50</code></pre>
<pre class="r"><code>f &lt;- a / b
print(f)</code></pre>
<pre><code>## [1] 0.1666667 0.2857143 0.3750000 0.4444444 0.5000000</code></pre>
<p>As we learned about earlier, these kind of operations of the vectors
is already vectorized, you don’t have to use any of the functions like
apply()</p>
<p>1.3. Find which elements of a are greater than 3.</p>
<pre class="r"><code>g &lt;- a &gt; 3
print(g)</code></pre>
<pre><code>## [1] FALSE FALSE FALSE  TRUE  TRUE</code></pre>
<p>1.4. Rewrite the operations using loops instead of vectorized
operations. I’ll just do the last one from 1.3.</p>
<pre class="r"><code>g &lt;- c()
for (i in a) {
  if (i &gt; 3) {
    g &lt;- append(g, TRUE)
  } else {
    g &lt;- append(g, FALSE)
  }
}
print(g)</code></pre>
<pre><code>## [1] FALSE FALSE FALSE  TRUE  TRUE</code></pre>
<p>That was indeed a lot more work than using vectorized operations.</p>
</div>
<div id="matrix-operations" class="section level3">
<h3>2. Matrix Operations</h3>
<p>2.1. Create a matrix mat &lt;- matrix(1:9, nrow = 3).</p>
<pre class="r"><code>mat &lt;- matrix(1:9, nrow = 3)
print(mat)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9</code></pre>
<p>2.2. Multiply each element of the matrix by 2 using vectorized
operations.</p>
<pre class="r"><code>mat_mult &lt;- mat*2
mat_mult</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    2    8   14
## [2,]    4   10   16
## [3,]    6   12   18</code></pre>
<p>2.3. Find the square of each element in the matrix.</p>
<pre class="r"><code>mat_square &lt;- mat^2
mat_square</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1   16   49
## [2,]    4   25   64
## [3,]    9   36   81</code></pre>
<p>2.4. Check which elements are greater than 5.</p>
<pre class="r"><code>mat &gt; 5</code></pre>
<pre><code>##       [,1]  [,2] [,3]
## [1,] FALSE FALSE TRUE
## [2,] FALSE FALSE TRUE
## [3,] FALSE  TRUE TRUE</code></pre>
</div>
<div id="apply-1" class="section level3">
<h3>3. apply()</h3>
<p>Using apply()</p>
<p>3.1. Create a matrix mat &lt;- matrix(rnorm(20), nrow = 5).</p>
<pre class="r"><code>mat &lt;- matrix(rnorm(20), nrow = 5)
mat</code></pre>
<pre><code>##             [,1]       [,2]       [,3]       [,4]
## [1,] -0.54159375 -1.6740705 -0.0920111 -0.2299882
## [2,] -0.02735148 -0.8395179 -0.7203667  0.8137564
## [3,] -1.08277738  0.3200057 -0.5097532  0.6992116
## [4,]  0.06565335  1.4934568 -0.1757002  1.8100932
## [5,]  1.51211178 -1.2742024  0.9545854 -1.4610005</code></pre>
<p>3.2. Use apply() to calculate the mean of each row.</p>
<pre class="r"><code>apply(mat, MARGIN = 1,  mean)</code></pre>
<pre><code>## [1] -0.63441589 -0.19336994 -0.14332832  0.79837578 -0.06712646</code></pre>
<p>3.3. Use apply() to find the sum of each column.</p>
<pre class="r"><code>apply(mat, MARGIN = 2, sum)</code></pre>
<pre><code>## [1] -0.07395747 -1.97432833 -0.54324591  1.63207242</code></pre>
<p>3.4. Write a custom function that calculates the range (max - min)
and use apply() to calculate the range for each row.</p>
<pre class="r"><code>apply(mat, MARGIN = 1, function(x) {max(x)-min(x)})</code></pre>
<pre><code>## [1] 1.582059 1.653274 1.781989 1.985793 2.973112</code></pre>
<p>I might actually be a genius. Just saying.</p>
</div>
<div id="using-lapply-and-sapply" class="section level3">
<h3>4. Using lapply() and sapply()</h3>
<p>4.1. Create a list of numeric vectors:</p>
<pre class="r"><code>my_list &lt;- list(a = 1:5, b = rnorm(10), c = runif(20))
my_list</code></pre>
<pre><code>## $a
## [1] 1 2 3 4 5
## 
## $b
##  [1] -0.41644432  2.00056606  0.31239028  0.71580378 -0.39538984  0.94338240
##  [7] -0.53526866 -0.08127385 -1.55020243  1.16658333
## 
## $c
##  [1] 3.713580e-01 5.201974e-01 4.684895e-01 3.323538e-01 4.161642e-01
##  [6] 9.527327e-01 7.364585e-01 4.577937e-01 1.348928e-05 7.262433e-01
## [11] 2.751679e-01 2.771581e-01 7.972446e-01 8.203043e-02 5.238943e-01
## [16] 8.048555e-01 1.705406e-01 7.608406e-01 9.090297e-01 4.664726e-01</code></pre>
<p>4.2. Use lapply() to calculate the mean of each vector.</p>
<pre class="r"><code>lapply(my_list, mean)</code></pre>
<pre><code>## $a
## [1] 3
## 
## $b
## [1] 0.2160147
## 
## $c
## [1] 0.5024519</code></pre>
<p>4.3. Use sapply() to calculate the standard deviation of each
vector.</p>
<pre class="r"><code>sapply(my_list, sd)</code></pre>
<pre><code>##         a         b         c 
## 1.5811388 1.0232028 0.2732433</code></pre>
<p>4.4. Create an anonymous function inside lapply() to find the sum of
squares for each vector.</p>
<pre class="r"><code>lapply(my_list, function(x) {sum(x^2)})</code></pre>
<pre><code>## $a
## [1] 55
## 
## $b
## [1] 9.889119
## 
## $c
## [1] 6.467735</code></pre>
</div>
<div id="using-tapply" class="section level3">
<h3>5. Using tapply()</h3>
<p>5.1. Create two vectors:</p>
<pre class="r"><code>values &lt;- c(10, 20, 30, 40, 50, 60, 70, 80)
groups &lt;- c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;, &quot;C&quot;, &quot;A&quot;, &quot;B&quot;)</code></pre>
<p>5.2. Use tapply() to calculate the mean of values grouped by
groups.</p>
<pre class="r"><code>tapply(values, groups, mean)</code></pre>
<pre><code>##        A        B        C 
## 33.33333 50.00000 55.00000</code></pre>
<p>5.3. Use tapply() to count the number of elements in each group.</p>
<pre class="r"><code>tapply(values, groups, length)</code></pre>
<pre><code>## A B C 
## 3 3 2</code></pre>
</div>
<div id="using-mapply---advanced" class="section level3">
<h3>6. Using mapply() - Advanced</h3>
<p>6.1. Write a function power_fun &lt;- function(base, exp) { base ^
exp }.</p>
<pre class="r"><code>power_fun &lt;- function(base, exp) { base ^ exp }</code></pre>
<p>6.2. Use mapply() to apply this function to base = c(2, 3, 4) and exp
= c(3, 2, 1).</p>
<pre class="r"><code>base = c(2, 3, 4)
exp = c(3, 2, 1)
mapply(power_fun, base, exp)</code></pre>
<pre><code>## [1] 8 9 4</code></pre>
<p>6.3. Compare the output with the manual calculation of each base
raised to its corresponding exponent.</p>
<pre class="r"><code>for (i in 1:length(base)){
  print(power_fun(base[i],exp[i]))
}</code></pre>
<pre><code>## [1] 8
## [1] 9
## [1] 4</code></pre>
</div>
<div id="combining-split-and-lapply---advanced" class="section level3">
<h3>7. Combining split() and lapply() - Advanced</h3>
<p>7.1. Create a data frame:</p>
<pre class="r"><code>df &lt;- data.frame(
  id = 1:12,
  group = rep(c(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;), each = 4),
  score = rnorm(12, mean = 75, sd = 10)
)
df</code></pre>
<pre><code>##    id group    score
## 1   1     X 61.13301
## 2   2     X 81.25121
## 3   3     X 83.78483
## 4   4     X 82.05420
## 5   5     Y 65.64827
## 6   6     Y 60.67791
## 7   7     Y 78.56560
## 8   8     Y 55.94615
## 9   9     Z 77.88460
## 10 10     Z 69.99812
## 11 11     Z 90.61512
## 12 12     Z 55.55310</code></pre>
<p>7.2. Use split() to split the data frame by group.</p>
<pre class="r"><code>split(df, df$group)</code></pre>
<pre><code>## $X
##   id group    score
## 1  1     X 61.13301
## 2  2     X 81.25121
## 3  3     X 83.78483
## 4  4     X 82.05420
## 
## $Y
##   id group    score
## 5  5     Y 65.64827
## 6  6     Y 60.67791
## 7  7     Y 78.56560
## 8  8     Y 55.94615
## 
## $Z
##    id group    score
## 9   9     Z 77.88460
## 10 10     Z 69.99812
## 11 11     Z 90.61512
## 12 12     Z 55.55310</code></pre>
<p>7.3. Use lapply() to calculate the mean score for each group.</p>
<pre class="r"><code>lapply(split(df$score, df$group), mean)</code></pre>
<pre><code>## $X
## [1] 77.05581
## 
## $Y
## [1] 65.20948
## 
## $Z
## [1] 73.51274</code></pre>
<p>7.4. Write a combined split() and lapply() operation to count the
number of rows in each group.</p>
<pre class="r"><code>lapply(split(df, df$group), nrow)</code></pre>
<pre><code>## $X
## [1] 4
## 
## $Y
## [1] 4
## 
## $Z
## [1] 4</code></pre>
</div>
<div id="simulating-data-with-mapply---advanced" class="section level3">
<h3>8. Simulating Data with mapply() - Advanced</h3>
<p>8.1. Simulate data for 5 different groups, each with a mean and
standard deviation:</p>
<pre class="r"><code>means &lt;- c(5, 10, 15, 20, 25)
sds &lt;- c(1, 2, 3, 4, 5)
n &lt;- c(10, 15, 20, 25, 30)</code></pre>
<p>8.2. Use mapply() to generate random normal data for each group using
rnorm().</p>
<pre class="r"><code>mapply(rnorm, n, means, sds)</code></pre>
<pre><code>## [[1]]
##  [1] 5.175446 6.593929 4.972001 6.212214 6.541573 5.175851 5.367041 5.349077
##  [9] 4.979354 6.625947
## 
## [[2]]
##  [1] 11.441475 11.178267  5.617626  6.846727 12.021493  8.627050  7.703119
##  [8]  8.434207  7.832780  8.407590  8.116337  9.145193 11.512295 10.726038
## [15]  9.331938
## 
## [[3]]
##  [1] 17.69354 10.84114 14.92420 13.08170 19.12742 16.00757 11.67545 12.20723
##  [9] 15.28805 12.30886 15.14985 17.80240 19.23632 15.00160 10.08495 18.25284
## [17] 18.29907 14.13510 15.48024 13.38656
## 
## [[4]]
##  [1] 18.134167 18.654437 14.478099 14.628643 19.238643 16.552123 18.007843
##  [8] 15.438800 27.031627 16.463177 19.456612 19.778975 20.304149 26.482035
## [15] 23.140284 22.551205 22.102863 17.305893 21.758029 19.930651 18.086725
## [22] 18.657712 22.443832  8.766127 21.997322
## 
## [[5]]
##  [1] 25.50325 20.20103 26.74228 23.88710 34.19685 22.78981 30.04085 27.41140
##  [9] 22.84665 23.82466 26.67533 29.31072 18.69953 16.81804 15.30139 32.17154
## [17] 17.15642 19.54647 26.51973 24.78316 33.88690 18.59809 20.57987 22.78046
## [25] 17.94119 25.97080 14.28542 16.58520 25.26510 14.75983</code></pre>
</div>
<div id="combining-multiple-functions---challenge"
class="section level3">
<h3>9. Combining Multiple Functions - Challenge</h3>
<p>9.1. Create a data frame:</p>
<pre class="r"><code>df &lt;- data.frame(
  category = rep(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), each = 5),
  value1 = rnorm(15, 50, 10),
  value2 = rnorm(15, 30, 5)
)
df</code></pre>
<pre><code>##    category   value1   value2
## 1         A 57.89320 22.03425
## 2         A 52.05400 24.26628
## 3         A 57.93887 40.05833
## 4         A 49.74902 29.64731
## 5         A 46.56421 35.62302
## 6         B 50.01390 26.69877
## 7         B 51.89737 32.82431
## 8         B 36.87557 35.35570
## 9         B 60.55784 29.78443
## 10        B 67.73541 24.19402
## 11        C 40.72034 28.59275
## 12        C 50.13636 38.56932
## 13        C 51.59031 28.10567
## 14        C 39.53367 32.69687
## 15        C 24.12927 35.02464</code></pre>
<p>9.2. Use split() and lapply() to calculate the mean of value1 and
value2 for each category.</p>
<pre class="r"><code>lapply(split(df$value1, df$category), mean)</code></pre>
<pre><code>## $A
## [1] 52.83986
## 
## $B
## [1] 53.41602
## 
## $C
## [1] 41.22199</code></pre>
<pre class="r"><code>lapply(split(df$value2, df$category), mean)</code></pre>
<pre><code>## $A
## [1] 30.32584
## 
## $B
## [1] 29.77144
## 
## $C
## [1] 32.59785</code></pre>
<p>9.3. Use mapply() to calculate the sum of squares for value1 and
value2 for each category.</p>
<pre class="r"><code>mapply(function(x) { sum(x)^2 }, split(df$value1, df$category))</code></pre>
<pre><code>##        A        B        C 
## 69801.27 71331.78 42481.31</code></pre>
<pre class="r"><code>mapply(function(x) { sum(x)^2 }, split(df$value2, df$category))</code></pre>
<pre><code>##        A        B        C 
## 22991.42 22158.47 26565.49</code></pre>
<p>9.4. Compare the results with a loop-based approach.</p>
<pre class="r"><code>vect_a &lt;- c()
vect_b &lt;- c()
vect_c &lt;- c()
for (i in 1:length(df$category)){
  if (df$category[i] == &quot;A&quot;) {
    vect_a &lt;- append(vect_a, df$value1[i])
  } else if (df$category[i] == &quot;B&quot;) {
    vect_b &lt;- append(vect_b, df$value1[i])
  } else {
    vect_c &lt;- append(vect_c, df$value1[i])
  }
}
(mean(vect_a))</code></pre>
<pre><code>## [1] 52.83986</code></pre>
<pre class="r"><code>(mean(vect_b))</code></pre>
<pre><code>## [1] 53.41602</code></pre>
<pre class="r"><code>(mean(vect_c))</code></pre>
<pre><code>## [1] 41.22199</code></pre>
<p>That was a lot more extensive and thought-consuming than using
vectorized operations, I see the appeal</p>
</div>
<div id="advanced-matrix-manipulations---challenge"
class="section level3">
<h3>10. Advanced Matrix Manipulations - Challenge</h3>
<p>10.1 Create a 3D array:</p>
<pre class="r"><code>arr &lt;- array(1:24, dim = c(4, 3, 2))
arr</code></pre>
<pre><code>## , , 1
## 
##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12
## 
## , , 2
## 
##      [,1] [,2] [,3]
## [1,]   13   17   21
## [2,]   14   18   22
## [3,]   15   19   23
## [4,]   16   20   24</code></pre>
<p>10.2. Use apply() to calculate the sum along each dimension.</p>
<pre class="r"><code>apply(arr, MARGIN = 1, sum)</code></pre>
<pre><code>## [1] 66 72 78 84</code></pre>
<pre class="r"><code>apply(arr, MARGIN = 2, sum)</code></pre>
<pre><code>## [1]  68 100 132</code></pre>
<pre class="r"><code>apply(arr, MARGIN = 3, sum)</code></pre>
<pre><code>## [1]  78 222</code></pre>
<p>10.3. Use mapply() to scale the values in the array by different
factors for each layer.</p>
<pre class="r"><code>vect_mar &lt;- c(1, 2, 3)
vect_scale &lt;- c(10, 2, 3)
#mapply(function(x, y) {apply(arr, MARGIN = y, x*y)}, vect_mar, vect_scale)</code></pre>
<p>I got stuck here. I don’t know how to use anonymous functions to do
this. This is the solution that ChatGPT gave (with different variable
names):</p>
<pre class="rex"><code>arr &lt;- array(1:24, dim = c(4, 3, 2))  # A 4x3x2 array
factors &lt;- c(2, 3)  # Scaling factors for each layer

scaled_arr &lt;- mapply(function(slice, factor) slice * factor,
                     split(arr, slice.index(arr, 3)),  # Split by layers
                     factors,
                     SIMPLIFY = FALSE)  # Avoid simplifying to vectors
scaled_arr &lt;- array(unlist(scaled_arr), dim = dim(arr))  # Reshape to original dimensions</code></pre>
<p>Turns out that I misunderstood what ChatGPT meant with layers. I
though of that as being each dimension, but it meant each value of the
third dimension. Here is the code ChatGPT gave me when I asked it to
edit my code so that it would work:</p>
<pre class="r"><code>vect_mar &lt;- c(1, 2)
vect_scale &lt;- c(10, 2)

scaled_arr &lt;- mapply(
  function(margin, scale) {
    # Giving the data set as all rows, all columns, but varying levels
    apply(arr[, , margin], MARGIN = c(1, 2), function(x) x * scale)
  },
  vect_mar,
  vect_scale,
  # This part makes it so that the matrices are kept separate in the output and not combined + somehow making the third column part of first and second
  SIMPLIFY = FALSE
)

scaled_arr</code></pre>
<pre><code>## [[1]]
##      [,1] [,2] [,3]
## [1,]   10   50   90
## [2,]   20   60  100
## [3,]   30   70  110
## [4,]   40   80  120
## 
## [[2]]
##      [,1] [,2] [,3]
## [1,]   26   34   42
## [2,]   28   36   44
## [3,]   30   38   46
## [4,]   32   40   48</code></pre>
<p>I sort of get it, but not 100%. I think my main challenge here though
is the limitation in what I know about functions and maybe not so much
the vectorized operations. Functions might be an interesting portfolio
project for later. In the meantime, I will continue practicing
vectorized operations.</p>
<p>Trying it again as of 1st of May, 2025:</p>
<p>10.3. Use mapply() to scale the values in the array by different
factors for each layer.</p>
<pre class="r"><code>arr &lt;- array(1:24, dim = c(4, 3, 2))
scale &lt;- c(10, 2)
mapply(function(i, scale) {arr[,,i]*scale}, i = 1:2, scale, SIMPLIFY = FALSE)</code></pre>
<pre><code>## [[1]]
##      [,1] [,2] [,3]
## [1,]   10   50   90
## [2,]   20   60  100
## [3,]   30   70  110
## [4,]   40   80  120
## 
## [[2]]
##      [,1] [,2] [,3]
## [1,]   26   34   42
## [2,]   28   36   44
## [3,]   30   38   46
## [4,]   32   40   48</code></pre>
<p>I got it with a little help from ChatGPT. I was trying to do
mapply(function(arr, i, scale) {arr[,,i]*scale}, arr, i = 1:2, scale,
SIMPLIFY = FALSE), but it didn’t work because it couldn’t iterate
through arr. So arr can be called in the anonymous function, but not as
a parameter of it.</p>
</div>
<div id="working-from-loops-to-vectorized-operations---exercises"
class="section level2">
<h2>Working from loops to vectorized operations - Exercises</h2>
<p>The following section will have some exercises converting code using
loops to vectorized operations. I wanted to do this because I feel like
I can fairly easily think in terms of loops when designing code and I
want to practice thinking with vectorized operations instead. In
addition, it will help compare and contrast loops with vectorized
operations. The exercises are taken from ChatGPT.</p>
<div id="multiply-rows-of-a-matrix-by-a-vector" class="section level3">
<h3>11. Multiply Rows of a Matrix by a Vector</h3>
<p>Code with Loops:</p>
<pre class="r"><code># A 4x3 matrix
mat &lt;- matrix(1:12, nrow = 4, ncol = 3)

# A vector of scaling factors
scaling &lt;- c(2, 4, 6, 8)

# Using a loop to multiply each row by its corresponding factor
result &lt;- matrix(0, nrow = 4, ncol = 3)
for (i in 1:nrow(mat)) {
  result[i, ] &lt;- mat[i, ] * scaling[i]
}
result</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    2   10   18
## [2,]    8   24   40
## [3,]   18   42   66
## [4,]   32   64   96</code></pre>
<pre class="r"><code>mat &lt;- matrix(1:12, nrow = 4, ncol = 3)
scaling &lt;- c(2, 4, 6, 8)
#mapply(function(dat, scale) {})</code></pre>
<p>I think, at this point, that I can’t fully take advantage of the
vectorized operations before I learn to deal with functions better. I
will come back to this after I have worked through the module on
functions. If I still feel like I need more practice after that module,
I might make a separate portfolio project for that.</p>
<p>1st of May, 2025: I am back, now at the end of the semester. Let us
see whether I can do this exercise now.</p>
<pre class="r"><code>mat &lt;- matrix(1:12, nrow = 4, ncol = 3)
scaling &lt;- c(2, 4, 6, 8)
scaled_mat &lt;- mapply(function(mat, scaling) {mat*scaling}, mat, scaling)
scaled_mat &lt;- matrix(scaled_mat, nrow = 4, ncol = 3)
scaled_mat</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    2   10   18
## [2,]    8   24   40
## [3,]   18   42   66
## [4,]   32   64   96</code></pre>
</div>
<div id="calculate-column-means-of-a-matrix" class="section level3">
<h3>12. Calculate Column Means of a Matrix</h3>
<p>Code with loops:</p>
<pre class="r"><code># A 4x3 matrix
mat &lt;- matrix(1:12, nrow = 4, ncol = 3)

# Using a loop to calculate the mean of each column
col_means &lt;- numeric(ncol(mat))
for (j in 1:ncol(mat)) {
  col_means[j] &lt;- mean(mat[, j])
}
col_means</code></pre>
<pre><code>## [1]  2.5  6.5 10.5</code></pre>
<p>Code rewritten with vectorized functions:</p>
<pre class="r"><code># A 4x3 matrix
mat &lt;- matrix(1:12, nrow = 4, ncol = 3)

apply(mat, 2, mean)</code></pre>
<pre><code>## [1]  2.5  6.5 10.5</code></pre>
</div>
<div id="scale-elements-in-a-list" class="section level3">
<h3>13. Scale Elements in a List</h3>
<p>Code with loop:</p>
<pre class="r"><code># A list of numeric vectors
lst &lt;- list(a = 1:4, b = 5:8, c = 9:12)

# A vector of scaling factors
scaling &lt;- c(2, 3, 4)

# Using a loop to scale each element of the list by its corresponding factor
scaled_lst &lt;- list()
for (i in seq_along(lst)) {
  scaled_lst[[i]] &lt;- lst[[i]] * scaling[i]
}
scaled_lst</code></pre>
<pre><code>## [[1]]
## [1] 2 4 6 8
## 
## [[2]]
## [1] 15 18 21 24
## 
## [[3]]
## [1] 36 40 44 48</code></pre>
<p>Code with vectorized operations:</p>
<pre class="r"><code># A list of numeric vectors
lst &lt;- list(a = 1:4, b = 5:8, c = 9:12)

# A vector of scaling factors
scaling &lt;- c(2, 3, 4)

#lapply(lst, function(lst, scaling) {lst*scaling}, scaling)

mapply(function(lst, scaling) {lst*scaling}, lst, scaling, SIMPLIFY = FALSE)</code></pre>
<pre><code>## $a
## [1] 2 4 6 8
## 
## $b
## [1] 15 18 21 24
## 
## $c
## [1] 36 40 44 48</code></pre>
<p>I first tried using lapply, which didn’t work as it was going element
by element instead of list by list. mapply works by iterating over
parameters instead of elements. mapply therefore applies the nested
lists pairwise (e.g. lst[1] with mat[1] and lst[2] with mat[2]). The
functions therefore produce different results.</p>
</div>
<div id="calculate-grouped-means" class="section level3">
<h3>14. Calculate Grouped Means</h3>
<p>Code with loops:</p>
<pre class="r"><code># A numeric vector
x &lt;- c(5, 10, 15, 20, 25, 30, 35, 40, 45)

# A grouping factor
group &lt;- c(1, 1, 2, 2, 2, 3, 3, 3, 3)

# Using a loop to calculate the mean for each group
unique_groups &lt;- unique(group)
group_means &lt;- numeric(length(unique_groups))
for (i in seq_along(unique_groups)) {
  group_means[i] &lt;- mean(x[group == unique_groups[i]])
}
group_means</code></pre>
<pre><code>## [1]  7.5 20.0 37.5</code></pre>
<p>Code with vectorized operations:</p>
<pre class="r"><code># A numeric vector
x &lt;- c(5, 10, 15, 20, 25, 30, 35, 40, 45)

# A grouping factor
group &lt;- c(1, 1, 2, 2, 2, 3, 3, 3, 3)

tapply(x, group, mean)</code></pre>
<pre><code>##    1    2    3 
##  7.5 20.0 37.5</code></pre>
<p>Note that the output is a little different when using tapply(), as it
shows the grouping number as well as the means, while the solution with
loops only showed the means and the index alone identified the grouping
variable.</p>
</div>
<div id="reflection" class="section level3">
<h3>Reflection</h3>
<p>I have no worked through several exercises using vectorized
functions, and I think I am starting to get the logic behind it. I would
still need some more practice before I could confidently use all of the
functions, know their parameters, and the nuances between their outputs.
However, I think I have achieved my goal of learning the logic of
vectorized operations and being able to use them (with a little help
from the help section).</p>
</div>
</div>
<div id="anonymous-functions" class="section level2">
<h2>Anonymous Functions</h2>
<p>I have used anonymous functions quite a bit throughout this project,
so I thought I would formalize it by adding a section on what anonymous
functions are and how to use them.</p>
<p>An anonymous function is a function that is not stored as a variable,
but instead just used in that one instance. It therefore does not have a
name (hence “anonymous”). The syntax for the anonymous functions is
function(parameters) function_body. So you start with the word
“function”, then add any parameters you need, a space, and the action of
the function. Anonymous functions are great for short functions, but can
get messy if they are longer.</p>
</div>
<div
id="caveats-to-vectorized-operations---reflection-after-the-end-of-the-semester"
class="section level2">
<h2>Caveats to Vectorized Operations - Reflection after the end of the
semester</h2>
<p>After having learned more about R, worked on bigger projects in R,
and learned more about Tidyverse, I have learned that altough the
vectorized operations used here can often speed up the coding process
and make it more readable, there are situations in which other
approaches work better.</p>
<div id="loops" class="section level3">
<h3>Loops</h3>
<p>First, as stated in the introduction of this project, I started out
being very familiar with loops, but less so with vectorized operations.
I have however, through working on some of the applied projects coming
later, learned that loops sometimes work better than vectorized
operations. This occurs in scenarios where one wants to use the outcome
of one iteration in the next iteration. There might be some workarounds
for doing this with vectorized operations, but it seems like loops
(although a little slower) are easier to use for these purposes.
However, in any other case, vectorized operations make clearer code and
run faster than loops. Therefore, it seems like vectorized operations
should usually be used when I think about using loops.</p>
</div>
<div id="tidyverse-solutions" class="section level3">
<h3>Tidyverse solutions</h3>
<p>Tidyverse has a lot of useful functions that can sometimes mitigate
the need for using the vectorized functions investigated in the current
project. Therefore, it is usually good practice to google whether there
is a Tidyverse (or other) function for what you want to do before
starting to write code for it yourself. I have found several functions I
didn’t know about earlier from googling when I have needed something and
it has saved me from writing out a lot more complicated code. In
addition, there are often easier Tidyverse solutions compared to writing
code using the base R vectorized operations such as apply(). See next
project for more information about Tidyverse vs base R.</p>
</div>
</div>
<div id="cheat-sheet" class="section level2">
<h2>Cheat sheet</h2>
<p>Here is a quick overview of the different functions in base R for
vectorized operations and what they do, for reference later:</p>
<ul>
<li>lapply() - acts on a list and returns a list
<ul>
<li>Coerces the input to a list (nested if it has nested lists)</li>
<li>Has 3 parameters: list, function, parameters of the second
function</li>
</ul></li>
<li>sapply() - like lapply(), but with simplified results
<ul>
<li>Results in unnested lists or matrices if all of the lists have the
same lenght
<ul>
<li>If not, it produces the same results as lapply()</li>
</ul></li>
</ul></li>
<li>vapply() - similar to lapply() and sapply(), but also validates the
input type and length
<ul>
<li>Has a simplification parameter (similar to lapply() vs
sapply())</li>
</ul></li>
<li>tapply() - applies a function to defined groupings in the list
<ul>
<li>Has three parameters: x-vector, y-grouping, and function</li>
<li>Has a simplification parameter (similar to lapply() vs sapply())
apply() - applied to an array, like a data frame or matrix</li>
<li>If the parameter margins is 1, it will apply the function to each
row, while margins = 2 will apply the function to each column</li>
<li>The output will be a vector</li>
</ul></li>
<li>mapply() - Like running lapply() in parallel across parameters of a
function
<ul>
<li>mapply(function, funct_param1, funct_param2)</li>
</ul></li>
<li>Combining split() and lapply() - like tapply(), but with factors
instead of a grouping vector
<ul>
<li>Can also be used on data frames</li>
</ul></li>
</ul>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
